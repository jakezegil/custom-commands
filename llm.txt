# Custom Commands – Rules & Patterns

## Command Structure

### File Structure
Each command requires exactly 2 files:
1. **Command file** (e.g., `commands/fs`, `commands/ga`) - executable bash script in `commands/` directory
2. **Help file** (e.g., `help/fs.help`, `help/ga.help`) - formatted help documentation in `help/` directory

### Command File Requirements

#### 1. Shebang & Header
```bash
#!/bin/bash

# command-name: Brief description of what the command does
# Usage: command-name [options] [arguments]
# Additional context or notes
```

#### 2. Help Flag Handling
Always include this exact pattern:
```bash
if [[ "$1" == "-h" || "$1" == "--help" ]]                         ; then
if [[ -f "$(dirname "$(dirname "$0")")/help/COMMAND.help" ]]      ; then
echo -e "$(cat "$(dirname "$(dirname "$0")")/help/COMMAND.help")"
else
echo "Help file not found"
fi
exit 0
fi
```

#### 3. Dependency Checks
Check for required external tools:
```bash
if ! command -v TOOL &> /dev/null              ; then
echo "TOOL is required. Install it first." >&2
exit 1
fi
```

#### 4. Error Handling & Feedback
- Use colored output for user feedback
- Green (`\033[1;32m`) for success: `✔ Success message`
- Red (`\033[1;31m`) for errors: `✗ Error message`
- Reset with `\033[0m`
- Always check command exit codes

#### 5. File Permissions
- Make executable: `chmod +x command-name`
- The register script handles this automatically

### Help File Requirements

#### 1. Color Scheme
- Command name: `\033[1;32m` (green bold)
- Section headers: `\033[1;34m` (blue bold)
- Examples: `\033[1;33m` (yellow bold)
- Reset: `\033[0m`

#### 2. Required Sections
```
\033[1;32mCOMMAND\033[0m - Brief description

\033[1;34mUSAGE:\033[0m
command [options] [arguments]

\033[1;34mDESCRIPTION:\033[0m
Detailed explanation of what the command does.

\033[1;34mEXAMPLES:\033[0m
\033[1;33mcommand\033[0m Simple usage
\033[1;33mcommand --option value\033[0m With options

\033[1;34mREQUIREMENTS:\033[0m
• tool1
• tool2 (optional description)
```

#### 3. Optional Sections
- `FEATURES:` - Bullet points of key features
- `KEYBINDINGS:` - For interactive commands
- `OPTIONS:` - Detailed option descriptions

### Registration System

#### Automatic Discovery
The `register-commands.sh` script automatically:
- Discovers command files in the `commands/` directory
- Makes bash scripts executable
- Sources non-bash files from root (for shell functions)
- Adds `commands/` directory to PATH
- Updates shell profile with sourcing statements

#### Command Types
1. **Executable Scripts**: Start with `                                            #!/bin/bash` - become shell commands
2. **Sourceable Scripts**: No bash shebang - get sourced for functions/completions

#### Shell Profile Integration
- Creates auto-generated section between markers
- Backs up existing profile before modification
- Supports both zsh and bash

### Documentation Updates

#### README.md
When adding a new command, update the commands table:
```markdown
| Command | Purpose |
| ------- | -------------------------- |
| `cmd` | Brief description |
```

And add usage example:
```bash
cmd                    # Brief usage description
```

#### package.json
The register script is available as: `npm run register`

### Best Practices

#### Code Quality
- Prefer functional, composable code
- Use clear, explicit naming
- Keep functions small and focused
- Add comments for non-obvious logic
- Handle edge cases gracefully

#### User Experience
- Provide immediate, clear feedback
- Use consistent UI patterns across commands
- Include progress indicators for long operations
- Make error messages actionable
- Support `--help` on all commands

#### Dependencies
- Check for required tools before execution
- Provide clear installation instructions in help
- Gracefully handle missing optional dependencies
- Document all external tool requirements

#### Testing
- Test on both zsh and bash
- Verify commands work after registration
- Test help output formatting
- Validate error conditions

### Command Naming Conventions
- Keep short and memorable (2-4 characters preferred)
- Use lowercase letters
- Avoid conflicts with system commands
- Group related commands with prefixes (e.g., `g*` for git commands)

### Integration Patterns
- Commands can call other commands in the system
- Use `source` to share common functions
- Maintain clean dependency mappings
- Design for composability and reuse

### Security Considerations
- Always quote variables to prevent word splitting
- Use `$()` instead of backticks for command substitution
- Validate input parameters
- Use `>&2` for error messages to stderr
